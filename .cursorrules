# Cursor AI Rules Template

## MANDATORY: Read Before Starting
**ALWAYS read these docs before any development work:**
- `AI_QUICK_REFERENCE.md` - **START HERE** - Quick reference with links to all critical docs
- `AI_CONTEXT.md` - Complete development guidelines
- `public/docs/developers/architecture.md` - Type organization and API design rules
- `public/docs/developers/types.md` - Type system organization

## COMMAND APPROVAL CONFIGURATION
### Auto-Approved Commands (Safe Operations)
- File reading operations (`read_file`, `list_dir`, `file_search`)
- Code search operations (`codebase_search`, `grep_search`)
- Documentation reading
- Test execution (when using orchestrator)
- Cache clearing operations

### Require Confirmation (Potentially Destructive)
- File creation (`edit_file`, creating new files)
- File deletion (`delete_file`)
- Database operations
- Deployment commands
- Configuration changes
- Package installation/removal
- Git operations (except safe reads)

## CRITICAL RULES

### Type System (STRICT ENFORCEMENT)
- **NEVER** use inline types: `{ lng: number; lat: number }` ❌
- **ALWAYS** use canonical types: `GeoJSONCoordinate`, `BoundingBox`, `CenterCoordinate` ✅
- **NEVER** create duplicate type definitions
- **ALWAYS** import from correct location: `@/types/` (shared) vs `@/frontend-types/` (UI-only)

### API Development
- **ALWAYS** require `region` parameter for region-based endpoints
- **ALWAYS** use camelCase in API responses, snake_case only in database
- **NEVER** change API signatures without explicit user approval
- **ALWAYS** use PostGIS native functions for spatial operations

### Testing and Deployment (STRICT ENFORCEMENT)
- **ALWAYS** use the orchestrator for any testing or deployment operations
- **ALWAYS** use CarthorseOrchestrator for SQLite database exports - **NEVER** use direct CLI export commands
- **ALWAYS** exercise the primary intended codepath: `npx ts-node src/orchestrator/CarthorseOrchestrator.ts export --region <region> --out <file.db>`

### Data Integrity (FAIL-FAST ENFORCEMENT)
- **NEVER** handle missing data gracefully - **ALWAYS** fail hard and fast
- **NEVER** use defensive programming for data issues - throw errors immediately
- **ALWAYS** validate data integrity at boundaries (API, database, file imports)
- **NEVER** provide fallbacks for missing elevation, coordinates, or critical trail data
- **ALWAYS** throw descriptive errors that identify the root cause (e.g., "carthorse export missing elevation data")
- **NEVER** backfill or calculate missing data - fix the source (carthorse, database schema, etc.)
- **ALWAYS** assume data is correct and complete - if not, the system is broken

### Development Workflow
- **ALWAYS** get user permission before creating new files
- **ALWAYS** search existing code before creating new functionality
- **ALWAYS** run tests before committing
- **ALWAYS** update documentation for architectural changes

## Project Overview
- **Name**: Carthorse - Trail data processing and export system
- **Architecture**: Node.js + PostgreSQL + PostGIS
- **Key Features**: Trail data processing, geometry handling, elevation data, multi-region exports
- **Deployment**: CLI tool with Docker support 

# Cursor Rules for Database Discussions

## Database Table References
- **ALWAYS** use fully qualified table names in the format `schemaname.tablename` when discussing database tables
- **NEVER** refer to tables without their schema prefix
- **ALWAYS** specify the database name when discussing cross-database operations
- **ALWAYS** use the format `database.schemaname.tablename` when the database context is important

## Examples of Correct Usage:
- ✅ `public.trails` (not just "trails")
- ✅ `staging_boulder_1754057151085.trails` (not just "staging table")
- ✅ `trail_master_db_test.public.trails` (when database context matters)
- ✅ `information_schema.columns` (for system tables)

## Examples of Incorrect Usage:
- ❌ "trails table" (missing schema)
- ❌ "the staging table" (missing schema)
- ❌ "geometry column" (missing table and schema)

## Database Context Rules:
- When discussing PostgreSQL: always include schema (e.g., `public.trails`)
- When discussing SQLite: include database file name if relevant (e.g., `boulder-export.db.trails`)
- When discussing cross-database operations: include both database and schema names
- When discussing system tables: use full qualification (e.g., `information_schema.columns`)

## Column References:
- When discussing columns, use the format: `schemaname.tablename.columnname`
- Example: `public.trails.geometry` instead of "geometry column"

This ensures clear communication about which specific database objects we're discussing. 